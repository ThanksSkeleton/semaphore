"use strict";(self.webpackChunk_semaphore_docs=self.webpackChunk_semaphore_docs||[]).push([[662],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,u=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),h=s(n),d=i,m=h["".concat(u,".").concat(d)]||h[d]||p[d]||a;return n?r.createElement(m,l(l({ref:t},c),{},{components:n})):r.createElement(m,l({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,l=new Array(a);l[0]=h;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<a;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8923:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return c},default:function(){return h}});var r=n(3117),i=n(102),a=(n(7294),n(3905)),l=["components"],o={sidebar_position:1},u="Circuits",s={unversionedId:"technical-reference/circuits",id:"version-V2/technical-reference/circuits",title:"Circuits",description:"Semaphore circuits are the heart of the protocol and essentially allow you to prove:",source:"@site/versioned_docs/version-V2/technical-reference/circuits.md",sourceDirName:"technical-reference",slug:"/technical-reference/circuits",permalink:"/docs/technical-reference/circuits",editUrl:"https://github.com/appliedzkp/semaphore/edit/main/versioned_docs/version-V2/technical-reference/circuits.md",tags:[],version:"V2",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"version-V2/mySidebar",previous:{title:"Signals",permalink:"/docs/guides/signals"},next:{title:"Contracts",permalink:"/docs/technical-reference/contracts"}},c=[{value:"1. Merkle tree",id:"1-merkle-tree",children:[],level:2},{value:"2. Nullifier",id:"2-nullifier",children:[],level:2},{value:"3. Signal",id:"3-signal",children:[],level:2}],p={toc:c};function h(e){var t=e.components,n=(0,i.Z)(e,l);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"circuits"},"Circuits"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/semaphore/tree/main/circuits"},"Semaphore circuits")," are the heart of the protocol and essentially allow you to prove:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Merkle tree"),": that the identity commitment exists in the Merkle tree,"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Nullifiers"),": that the signal was only broadcasted once,"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Signal"),": that the signal was truly broadcasted by the user who generated the proof.")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://github.com/appliedzkp/semaphore/raw/main/circuits/scheme.png",alt:"Semaphore circuit"})),(0,a.kt)("h2",{id:"1-merkle-tree"},"1. Merkle tree"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Private inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_nullifier"),": a random 32-byte value which the user should save,"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_trapdoor"),": a random 32-byte value which the user should save,"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_path_elements"),": the values along the Merkle path to the user's identity commitment,"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_path_index[n_levels]"),": the direction (left/right) per tree level corresponding to the Merkle path to the user's identity commitment.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Public outputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"root"),": The Merkle root of the identity tree.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Procedure:")),(0,a.kt)("p",null,"The circuit hashes the public key, identity nullifier, and identity trapdoor to\ngenerate an ",(0,a.kt)("strong",{parentName:"p"},"identity commitment"),". It then verifies the Merkle proof against\nthe Merkle root and the identity commitment."),(0,a.kt)("h2",{id:"2-nullifier"},"2. Nullifier"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Private inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_nullifier"),": a random 32-byte value which the user should save,"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_trapdoor"),": a random 32-byte value which the user should save,")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Public inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"external_nullifier"),": the 29-byte external nullifier - see above")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Public outputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nullifiers_hash"),": the hash of the identity nullifier, external nullifier,\nand Merkle path index (",(0,a.kt)("inlineCode",{parentName:"li"},"identity_path_index"),")")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Procedure:")),(0,a.kt)("p",null,"The circuit hashes the given identity nullifier, external nullifier, and Merkle\npath index, and checks that it matches the given nullifiers hash. Additionally,\nthe smart contract ensures that it has not previously seen this nullifiers\nhash. This way, double-signalling is impossible."),(0,a.kt)("h2",{id:"3-signal"},"3. Signal"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Public inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"signal_hash"),": ...")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Procedure:")),(0,a.kt)("p",null,"The circuit hashes the signal hash and the external nullifier, and verifies\nthis output against the given public key and signature. This ensures the\nauthenticity of the signal and prevents front-running attacks."))}h.isMDXComponent=!0}}]);